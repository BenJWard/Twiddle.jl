{
    "docs": [
        {
            "location": "/", 
            "text": "Twiddle.jl \nBit-twiddling tricks for Julia\n\n\n \n \n \n \n \n \n\n\nTwiddle.jl is a package collecting useful bit-twiddling tricks, ready to use as functions, with detailed documentation of what they do, and example real-world use cases.\n\n\nThis package originated from a PostDoc project where we wanted to do some common biological sequence operations much much faster than a naive implementation could, by taking advantage of succinct bit-encoding of the sequences.\n\n\nThis package however is supposed to be more general, and we want it to contain many bit-twiddling tips and tricks.\n\n\n\n\nQuick Start\n\n\nInstall the latest version of Twiddle.jl from the Julia REPL:\n\n\nPkg\n.\nadd\n(\nTwiddle\n)\n\n\n\n\n\n\nINFO\n:\n \nNothing\n \nto\n \nbe\n \ndone\n\n\n\n\n\n\nTo use any functions in Twiddle, you must \nfully qualify\n the name e.g.\n\n\nusing\n \nTwiddle\n\n\n\nTwiddle\n.\ncount_nonzero_nibbles\n(\n0x0F11F111F11111F1\n)\n\n\n\n\n\n\n15\n\n\n\n\n\nAlternatively, explicitly import the name e.g.\n\n\nusing\n \nTwiddle\n:\n \ncount_nonzero_nibbles\n\n\n\ncount_nonzero_nibbles\n(\n0x0F11F111F11111F1\n)\n\n\n\n\n\n\n15", 
            "title": "Twiddle"
        }, 
        {
            "location": "/#twiddlejl-bit-twiddling-tricks-for-julia", 
            "text": "Twiddle.jl is a package collecting useful bit-twiddling tricks, ready to use as functions, with detailed documentation of what they do, and example real-world use cases.  This package originated from a PostDoc project where we wanted to do some common biological sequence operations much much faster than a naive implementation could, by taking advantage of succinct bit-encoding of the sequences.  This package however is supposed to be more general, and we want it to contain many bit-twiddling tips and tricks.", 
            "title": "Twiddle.jl Bit-twiddling tricks for Julia"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Install the latest version of Twiddle.jl from the Julia REPL:  Pkg . add ( Twiddle )   INFO :   Nothing   to   be   done   To use any functions in Twiddle, you must  fully qualify  the name e.g.  using   Twiddle  Twiddle . count_nonzero_nibbles ( 0x0F11F111F11111F1 )   15  Alternatively, explicitly import the name e.g.  using   Twiddle :   count_nonzero_nibbles  count_nonzero_nibbles ( 0x0F11F111F11111F1 )   15", 
            "title": "Quick Start"
        }, 
        {
            "location": "/reference/", 
            "text": "Reference Manual\n\n\n#\n\n\nTwiddle.count_nonzero_nibbles\n \n \nMethod\n.\n\n\ncount_nonzero_nibbles{T\n:Unsigned}(x::T)\n\n\n\n\n\nCount the number of nibbles (aligned 4 bit segments) in an unsigned integer \nx\n which have at least one bit set.\n\n\nE.g. An input of:\n\n\n0x0F11F111F11111F1\n\n\nWould give the answer: 15.\n\n\nsource\n\n\n#\n\n\nTwiddle.count_one_nibbles\n \n \nMethod\n.\n\n\ncount_one_nibbles{T\n:Unsigned}(x::T)\n\n\n\n\n\nCounts the number of nibbles (aligned 4 bit segments) in an unsigned integer \nx\n that have all their bits set i.e. counts all nibbles of 1111 in an integer.\n\n\nE.g. An input of:\n\n\n0x0F11F111F11111F1\n\n\nWould give the answer: 4.\n\n\nsource\n\n\n#\n\n\nTwiddle.count_zero_nibbles\n \n \nMethod\n.\n\n\ncount_zero_nibbles{T\n:Unsigned}(x::T)\n\n\n\n\n\nCounts the number of nibbles (aligned 4 bit segments) in an unsigned integer \nx\n that have all their bits unset i.e. nibbles of 0000.\n\n\nE.g. An input of:\n\n\n0x0F11F111F11111F1\n\n\nWould give the answer: 1.\n\n\nsource\n\n\n#\n\n\nTwiddle.enumerate_nibbles\n \n \nMethod\n.\n\n\nenumerate_nibbles\n{\nT\n:\nUnsigned\n}(\nx\n::\nT\n)\n\n\n\n\n\nCount the number of set bits in each nibble (aligned 4 bit segments) of an unsigned integer \nx\n.\n\n\nE.g. An input of:\n\n\n0100 0010 0001 0110 1100 1110 1101 1111\n\n\nWould result in:\n\n\n0001 0001 0001 0010 0010 0011 0011 0100\n\n\nThis is used to identify different occurances of certain bit patterns.\n\n\nsource\n\n\n#\n\n\nTwiddle.mask\n \n \nMethod\n.\n\n\nmask{T\n:Unsigned}(::Type{T}, n::Integer)\n\n\n\n\n\nCreates a bit mask for given number of bits \nn\n.\n\n\nThe mask starts from the least significant bit, and end at bit \nn\n.\n\n\ne.g:\n\n\njulia\n Twiddle.mask(UInt64, 8)\n0x00000000000000ff\n\n\n\n\n\nsource\n\n\n#\n\n\nTwiddle.nibble_capacity\n \n \nMethod\n.\n\n\nnibble_capacity{T\n:Unsigned}(::Type{T})\n\n\n\n\n\nReturns the number of nibbles that an unsigned integer of type \nT\n holds. This is essentially twice the size of the type (in bytes).\n\n\nsource\n\n\n#\n\n\nTwiddle.nibble_mask\n \n \nMethod\n.\n\n\nnibble_mask{T\n:Unsigned}(value::T, x::T)\n\n\n\n\n\nCreate a mask for the nibbles (aligned 4 bit segments) in an unsigned integer \nx\n that filter nibbles matching the corresponding nibble in \nvalue\n.\n\n\nsource\n\n\n#\n\n\nTwiddle.repeatbyte\n \n \nMethod\n.\n\n\nrepeatbyte{T\n:Unsigned}(::Type{T}, byte::UInt8)\n\n\n\n\n\nRepeats the bitpattern of the \nbyte\n throughout the an Unsigned integer of type \nT\n.\n\n\nThis is useful for bit-twiddling code that is to work on any word size.\n\n\nLet's use a very simple example to show why this is useful. Let's say you have a function in which a byte is masked with a bitmask 0x33.\n\n\nf\n(\nx\n::\nUInt8\n)\n \n=\n \nx\n \n \n0x33\n\n\n\n\n\n\nSuppose you wanted this to work for any word size, so 8 bit, 16 bit, 32 bit, 64 bit, and 128 bit words? One way is to write \nf\n as a set of seperate methods:\n\n\nf\n(\nx\n::\nUInt8\n)\n \n=\n \nx\n \n \n0x33\n\n\nf\n(\nx\n::\nUInt16\n)\n \n=\n \nx\n \n \n0x3333\n\n\nf\n(\nx\n::\nUInt32\n)\n \n=\n \nx\n \n \n0x33333333\n\n\nf\n(\nx\n::\nUInt64\n)\n \n=\n \nx\n \n \n0x3333333333333333\n\n\nf\n(\nx\n::\nUInt128\n)\n \n=\n \nx\n \n \n0x33333333333333333333333333333333\n\n\n\n\n\n\nThis is clearly not ideal, you would be writing out the same method multiplet times, but with a differently sized literal for the mask each time.\n\n\nAlternatively, you could write one parametric function with repeatbyte:\n\n\nf2\n{\nT\n:\nUnsigned\n}(\nx\n::\nT\n)\n \n=\n \nx\n \n \nTwiddle\n.\nrepeatbyte\n(\nT\n,\n \n0x33\n)\n\n\n\n\n\n\nYou might expect this to be less efficient - \nrepeatbyte\n uses several operations to generate the values 0x33, 0x3333 and so on, whereas in the seperate methods, those literal values are hard coded. However, thanks to constant folding during compilation, those operations are done once at compilation time and so the native instructions generated are identical.\n\n\nsource\n\n\n#\n\n\nTwiddle.swapbits\n \n \nMethod\n.\n\n\nswapbits{T\n:Unsigned}(x::T, i::Integer, j::Integer)\n\n\n\n\n\nSwap the i'th and j'th bits in an unsigned integer. Note this uses zero based indexes for \ni\n and \nj\n.\n\n\nE.g. to swap the LSB and MSB of a byte: 1001 1000 (0x98) -\n 0001 1001 (0x19)\n\n\n@example\nswapbits(0x98, 0, 7)\n\n\nsource", 
            "title": "Reference Manual"
        }, 
        {
            "location": "/reference/#reference-manual", 
            "text": "#  Twiddle.count_nonzero_nibbles     Method .  count_nonzero_nibbles{T :Unsigned}(x::T)  Count the number of nibbles (aligned 4 bit segments) in an unsigned integer  x  which have at least one bit set.  E.g. An input of:  0x0F11F111F11111F1  Would give the answer: 15.  source  #  Twiddle.count_one_nibbles     Method .  count_one_nibbles{T :Unsigned}(x::T)  Counts the number of nibbles (aligned 4 bit segments) in an unsigned integer  x  that have all their bits set i.e. counts all nibbles of 1111 in an integer.  E.g. An input of:  0x0F11F111F11111F1  Would give the answer: 4.  source  #  Twiddle.count_zero_nibbles     Method .  count_zero_nibbles{T :Unsigned}(x::T)  Counts the number of nibbles (aligned 4 bit segments) in an unsigned integer  x  that have all their bits unset i.e. nibbles of 0000.  E.g. An input of:  0x0F11F111F11111F1  Would give the answer: 1.  source  #  Twiddle.enumerate_nibbles     Method .  enumerate_nibbles { T : Unsigned }( x :: T )  Count the number of set bits in each nibble (aligned 4 bit segments) of an unsigned integer  x .  E.g. An input of:  0100 0010 0001 0110 1100 1110 1101 1111  Would result in:  0001 0001 0001 0010 0010 0011 0011 0100  This is used to identify different occurances of certain bit patterns.  source  #  Twiddle.mask     Method .  mask{T :Unsigned}(::Type{T}, n::Integer)  Creates a bit mask for given number of bits  n .  The mask starts from the least significant bit, and end at bit  n .  e.g:  julia  Twiddle.mask(UInt64, 8)\n0x00000000000000ff  source  #  Twiddle.nibble_capacity     Method .  nibble_capacity{T :Unsigned}(::Type{T})  Returns the number of nibbles that an unsigned integer of type  T  holds. This is essentially twice the size of the type (in bytes).  source  #  Twiddle.nibble_mask     Method .  nibble_mask{T :Unsigned}(value::T, x::T)  Create a mask for the nibbles (aligned 4 bit segments) in an unsigned integer  x  that filter nibbles matching the corresponding nibble in  value .  source  #  Twiddle.repeatbyte     Method .  repeatbyte{T :Unsigned}(::Type{T}, byte::UInt8)  Repeats the bitpattern of the  byte  throughout the an Unsigned integer of type  T .  This is useful for bit-twiddling code that is to work on any word size.  Let's use a very simple example to show why this is useful. Let's say you have a function in which a byte is masked with a bitmask 0x33.  f ( x :: UInt8 )   =   x     0x33   Suppose you wanted this to work for any word size, so 8 bit, 16 bit, 32 bit, 64 bit, and 128 bit words? One way is to write  f  as a set of seperate methods:  f ( x :: UInt8 )   =   x     0x33  f ( x :: UInt16 )   =   x     0x3333  f ( x :: UInt32 )   =   x     0x33333333  f ( x :: UInt64 )   =   x     0x3333333333333333  f ( x :: UInt128 )   =   x     0x33333333333333333333333333333333   This is clearly not ideal, you would be writing out the same method multiplet times, but with a differently sized literal for the mask each time.  Alternatively, you could write one parametric function with repeatbyte:  f2 { T : Unsigned }( x :: T )   =   x     Twiddle . repeatbyte ( T ,   0x33 )   You might expect this to be less efficient -  repeatbyte  uses several operations to generate the values 0x33, 0x3333 and so on, whereas in the seperate methods, those literal values are hard coded. However, thanks to constant folding during compilation, those operations are done once at compilation time and so the native instructions generated are identical.  source  #  Twiddle.swapbits     Method .  swapbits{T :Unsigned}(x::T, i::Integer, j::Integer)  Swap the i'th and j'th bits in an unsigned integer. Note this uses zero based indexes for  i  and  j .  E.g. to swap the LSB and MSB of a byte: 1001 1000 (0x98) -  0001 1001 (0x19)  @example\nswapbits(0x98, 0, 7)  source", 
            "title": "Reference Manual"
        }, 
        {
            "location": "/nibbles/", 
            "text": "Working with Nibbles\n\n\n\n\nWhat is a nibble?\n\n\nA nibble (often nybble or nyble to match the vowels of byte) is a four-bit aggregation. It is also sometimes called a half-byte or tetrade.\n\n\nA nibble has sixteen possible values. A nibble can be represented by a single hexadecimal digit, called a hex digit.\n\n\nFor example, if you wanted to represent the byte 00001111, you would use two hex digits, one hex digit would represent the 0000 bits, and a second hex digit would represent the 1111 bits. So the byte - the two nibbles - are represented in hexadecimal notation as: 0x0F. The hex digit 0 = the 0000 nibble, and the hex digit F = the 1111 nibble.\n\n\n\n\nWhy would you want to manipulate nibbles?\n\n\n\n\nIn Bioinformatics...\n\n\nYou may have some data encoded in a succinct format that stores memory and will speed up computation, but that requires manipulating bits of binary data.\n\n\nIn the BioJulia package ecosystem, DNA sequences can be represented in a compressed format where a single nucleotide is represented with a nibble.\n\n\nSince many nibbles can fit in a single integer, bit parallel manipulation of such binary data allows you to do operations on many nibbles (nucleotides) at once, speeding up your computation significantly!\n\n\n\n\nNibble methods\n\n\n\n\nTwiddle.nibble_capacity\n\n\nTwiddle.enumerate_nibbles\n\n\nTwiddle.count_nonzero_nibbles\n\n\nTwiddle.count_zero_nibbles\n\n\nTwiddle.count_one_nibbles\n\n\nTwiddle.nibble_mask", 
            "title": "Working with Nibbles"
        }, 
        {
            "location": "/nibbles/#working-with-nibbles", 
            "text": "", 
            "title": "Working with Nibbles"
        }, 
        {
            "location": "/nibbles/#what-is-a-nibble", 
            "text": "A nibble (often nybble or nyble to match the vowels of byte) is a four-bit aggregation. It is also sometimes called a half-byte or tetrade.  A nibble has sixteen possible values. A nibble can be represented by a single hexadecimal digit, called a hex digit.  For example, if you wanted to represent the byte 00001111, you would use two hex digits, one hex digit would represent the 0000 bits, and a second hex digit would represent the 1111 bits. So the byte - the two nibbles - are represented in hexadecimal notation as: 0x0F. The hex digit 0 = the 0000 nibble, and the hex digit F = the 1111 nibble.", 
            "title": "What is a nibble?"
        }, 
        {
            "location": "/nibbles/#why-would-you-want-to-manipulate-nibbles", 
            "text": "", 
            "title": "Why would you want to manipulate nibbles?"
        }, 
        {
            "location": "/nibbles/#in-bioinformatics", 
            "text": "You may have some data encoded in a succinct format that stores memory and will speed up computation, but that requires manipulating bits of binary data.  In the BioJulia package ecosystem, DNA sequences can be represented in a compressed format where a single nucleotide is represented with a nibble.  Since many nibbles can fit in a single integer, bit parallel manipulation of such binary data allows you to do operations on many nibbles (nucleotides) at once, speeding up your computation significantly!", 
            "title": "In Bioinformatics..."
        }, 
        {
            "location": "/nibbles/#nibble-methods", 
            "text": "Twiddle.nibble_capacity  Twiddle.enumerate_nibbles  Twiddle.count_nonzero_nibbles  Twiddle.count_zero_nibbles  Twiddle.count_one_nibbles  Twiddle.nibble_mask", 
            "title": "Nibble methods"
        }, 
        {
            "location": "/glossary/", 
            "text": "Glossary\n\n\nHere we clarify some terms commonly used when manipulating bits.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary", 
            "text": "Here we clarify some terms commonly used when manipulating bits.", 
            "title": "Glossary"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nWe welcome contributions of all kinds.\n\n\nTo make a contribution simply fork this repository, make your changes, and then make a pull request.\n\n\nPlease note that we use the one-flow branching model for this repository and so please ensure your pull request are made to the 'develop' branch as the reference branch you are to merge your changes into.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "We welcome contributions of all kinds.  To make a contribution simply fork this repository, make your changes, and then make a pull request.  Please note that we use the one-flow branching model for this repository and so please ensure your pull request are made to the 'develop' branch as the reference branch you are to merge your changes into.", 
            "title": "Contributing"
        }, 
        {
            "location": "/license/", 
            "text": "MIT License\n\n\nCopyright (c) 2017 Ben J. Ward \n Luis Yanes\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "Licence"
        }
    ]
}